<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>ICWE 2021 - A file-based Approach to Prefix Search</title>

    <link rel="stylesheet"href="dist/reset.css">
    <link rel="stylesheet"href="dist/reveal.css">
    <link rel="stylesheet"href="dist/theme/white.css"id="theme">
    <link rel="stylesheet"href="dist/mycss.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet"href="plugin/highlight/monokai.css"id="highlight-theme">
  </head>
  <body>
    <img style="position: absolute; left:10px; bottom: 10px; height: 15vh;" src="dist/assets/ugent_logo.png" alt="image">
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>A File-based Linked Data Fragments Approach To Prefix Search</h2>
          <p>Ruben Dedecker, Harm Delva, Pieter Colpaert, and Ruben Verborgh</p>
          <p>IDLab, Ghent University - imec</p>
          <aside class="notes">
            <ul>
              <li>Hello everyone, </li>
              <li>My name is Ruben Dedecker from the IDLab research group at Ghent University.</li>
              <li>This video is my presentation for the ICWE2021 conference.</li>
              <li>I come to present our latest work on a file-based linked data fragments approach to prefix search.       </li>
            </ul>
            
            
            
            
          </aside>
        </section>

        <section>
          <h3>Querying data collections on the Web</h3>
          <section>
            </br>
            <img style="width: auto" src="dist/assets/intro_1.png" alt="image">
            <aside class="notes">   
              <ul>
                <li>
                  applications use available data collections on the Web.
                </li>
                <li>
                  application does not require all available data.
                </li>
                <li>
                  Only relevant for the user.
                </li>
                <li>
                  One of the primary ways to extract this data is prefix search.
                </li>
                <li>
                  If user is unsure, speedup queries on mobile.
                </li>
                <li>
                  this example, user only wants transport stops relevant to their start / destination.
                </li>
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <h3>What are the options</h3>
          <section>
            <div>
              </br>
              <p>A server API</p>
              <img style="height: 50vh" src="dist/assets/approach_server.svg" alt="image">
            </div>
            <aside class="notes">   
              <ul>
                <li>So how can we provide This</li>
                <li>one way is to use a server API</li>
                <li>server indexes data, exposes interface over web</li>
                <li>client can make http requests for specific prefix</li>
                <li>Server is responsible for querying process</li>
              </ul>
            </aside>
          </section>
          <section>
            <div>
              </br>
              <p>A server API</p>
              <img style="margin: 0; padding: 0; height: 60vh" src="dist/assets/elasticsearch.png" alt="image">
            </div>
            <aside class="notes">    
              <ul>
                <li>powerful open source tools available</li>
                <li>setup cost, maintenance</li>
                <li>needs active server environment, no github pages</li>
                <li>can be expensive, require request throttling</li>

              </ul>    
            </aside>
          </section>
          <section>
            <div>
              </br>
              <p>Rely on third parties</p>
              <img style="height: 50vh" src="dist/assets/approach_client.svg" alt="image">
            </div>
            <aside class="notes">   
              <ul>
                <li>other option publish full dataset</li>
                <li>rely on third party reusers to provide interface</li>
                <li>client retrieve full dataset</li>
                <li>low cost, can make use of static services like github pages</li>
              </ul>      
            </aside>
          </section>
        </section>

        <section>
          <h3>What about fragmentation?</h3>
          <section>
            </br>
            <div>
              <p>Can dataset fragmentation provide a middle ground?</p>
              <img style="height: 50vh" src="dist/assets/our_approach2.png" alt="image">
            </div>
            <aside class="notes"> 
              <ul>
                <li>With this work, provide in between solution</li>
                <li>able to publish to static services such as github pages with minimal maintenance</li>
                <li>provide richer interface that enables clients to evaluate prefix queries</li>
                <li>client can control prefix autocompletion process</li>
                <li>still enable straightforward retrieval of dataset</li>
              </ul>        
            </aside>
          </section>
          <section>
            <div>
              </br>
              <p>Inspired by </p>
              <img style="height: 50vh" src="dist/assets/LDF.svg" alt="image">
            </div>
            <aside class="notes">   
              <ul>
              <li>based on prior work on Linked Data Fragments</li>     
              <li>idea of letting clients evaluate queries over fragments of a dataset</li>     
              <li>TPF</li>
              <li>client can solve sparql, slow if you have no identifiers</li>
              </ul> 
            </aside>
          </section>
        </section>

        <section>
          <h3>Our proposal</h3>
          <section data-transition="fade" data-transition-speed="fast">
            <p>A file-based architecture for prefix search with an acceptable user-perceived performance that enables clients to take control of the query evaluation process</p>
            <aside class="notes">         
              <ul>
                <li>Leads us to our proposal</li>
                <li>A file based architecture for prefix search with an acceptable user-perceived performance that enables clients to take control of the query evaluation process.</li>
                <li>Lets analyze this proposal</li>
              </ul>
            </aside>
          </section>
          <section data-transition="fade" data-transition-speed="fast">
            <p>A <b style="color:red">file-based architecture</b> for prefix search with an acceptable user-perceived performance that enables clients to take control of the query evaluation process</p>
            <aside class="notes">   
              <ul>
                <li>publish a dataset as files on the web</li>
                <li>no active server component, make use of services such as github pages</li>
              </ul>      
            </aside>
          </section>
          <section data-transition="fade" data-transition-speed="fast">
            <p>A <b style="color:red">file-based architecture</b> for <b style="color:red">prefix search</b> with an acceptable user-perceived performance that enables clients to take control of the query evaluation process</p>
            <aside class="notes">     
              <ul>
                <li>Our focus is on providing prefix search autocompletion</li>
                <li>client can match entities in the dataset with a given prefix value</li>
              </ul>    
            </aside>
          </section>
          <section data-transition="fade" data-transition-speed="fast">
            <p>A <b style="color:red">file-based architecture</b> for <b style="color:red">prefix search</b> with an acceptable <b style="color:red">user-perceived performance</b> that enables clients to take control of the query evaluation process</p>
            <aside class="notes">  
              <ul>
                <li>We focus on providing an acceptable user perceived performance for evaluating prefix queries</li>
                <li>focus of our evaluation</li>
              </ul>       
            </aside>
          </section>
          <section data-transition="fade" data-transition-speed="fast">
            <p>A <b style="color:red">file-based architecture</b> for <b style="color:red">prefix search</b> with an acceptable <b style="color:red">user-perceived performance</b> that <b style="color:red">enables clients to take control</b> of the query evaluation process</p>
            <aside class="notes">   
              <ul>
                <li>We aim to give the client control over autocompletion process</li>
                <li>independent of specific fragmentation strategy of server</li>
              </ul>      
            </aside>
          </section>
        </section>
    
        <section>
          <h3>What do we need</h3>
          <section data-auto-animate>
            <ul style="width: 70vw">
              <li>a dataset index</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul style="width: 70vw">
              <li>a dataset index</li>
              <li>a self-describing fragmentation</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul style="width: 70vw">
              <li>a dataset index</li>
              <li>a self-describing fragmentation</li>
              <li>a generic client</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul style="width: 70vw">
              <li style="color: red">a dataset index</li>
              <li>a self-describing fragmentation</li>
              <li>a generic client</li>
            </ul>
          </section>
          <aside class="notes">
            <ul>
              <li>To achieve this, we need three components</li>
              <li>A dataset index</li>
              <li>use to connect the dataset entities to a given prefix</li>
              <li>A self describing fragmentation</li>
              <li>allows clients to traverse the created search space, without having to know anything about fragmentation</li>
              <li>A generic client</li>
              <li>can traverse this created search space to evaluate prefix queries</li>
            </ul>         
          </aside>
        </section>


        <section>
          <h3>A dataset index</h3>
          <section>
            <div>
              </br>
              <p>what data properties</p>
              <pre data-id="code-animation"><code data-trim data-noescape data-line-numbers="|3,6-7">
                {
                  "@type":"Person",
                  "Name": "Carol Carolsson",
                  "Address": {
                    "Country": "Belgium",
                    "Municipality": "Ghent",
                    "Street": "Albertlaan",
                    "Number": 23
                  }
                }
                </code></pre>
            </div>
          </section>
          <section data-auto-animate>
            <div>
              </br>
              <div>
              <p data-id="toptext">what data structure</p>
              <div style="height: 45vh">
                <img data-id="tree-animation" style="height: 45vh" src="dist/assets/tree_0.svg" alt="image">
              </div>
            </div>
            </div>
          </section>
          <section data-auto-animate>
            <div>
              </br>
              <p data-id="toptext">balanced search trees</p>
              <div style="height: 45vh">
                <div style="width: 35%; float: left;">
                  <ul>
                    <li>maximum depth</li>
                  </ul>
                </div>
                <img data-id="tree-animation" style="width: 60%; float: left" src="dist/assets/tree_1.svg" alt="image">
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <div>
              </br>
              <p>balanced search trees</p>
              <div style="height: 45vh">
                <div style="width: 35%; float: left;">
                  <ul>
                    <li>maximum depth</li>
                    <li>caching</li>
                    <li>locality</li>
                  </ul>
                </div>
                <img data-id="tree-animation" style="width: 60%; float: left" src="dist/assets/tree_2.svg" alt="image">
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <div>
              </br>
              <p>balanced search trees</p>
              <div style="height: 45vh">
                <div style="width: 35%; float: left;">
                  <ul>
                    <li>maximum depth</li>
                    <li>caching</li>
                    <li>locality</li>
                    <li>streaming results</li>
                  </ul>
                </div>
                <img data-id="tree-animation" style="width: 60%; float: left" src="dist/assets/tree_3.svg" alt="image">
              </div>
            </div>
          </section>
          <aside class="notes">   
            <ul>
              <li>First decide on what properties we want to index</li>
              <li>example</li>
              <li>decide on datastructure</li>
              <li>chose balanced search trees for reasons listed</li>
              <li>more specifically B trees as can link to any amount of child nodes</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>What do we need</h3>
          <section>
            <ul style="width: 70vw">
              <li>a dataset index</li>
              <li style="color: red">a self-describing fragmentation</li>
              <li>a generic client</li>
            </ul>
          </section>
          <aside class="notes">   
            <ul>
              <li>Now that we have our data indexed, we need to fragment the dataset</li>
              <li>can be queried by client</li>
            </ul>
          </aside>
        </section>

        <section>
          <h3>A self-describing fragmentation</h3>
          <section data-auto-animate>
            <pre data-id="code-animation"><code data-trim data-noescape data-line-numbers>
              {
                "@id":"#Dataset",
                "@type":"Collection",
                ...
                "member":[
                  {
                    "@id": "/people/RubenD",
                    "fName": "Ruben",
                    "lName": "Dedecker",
                  },
                  {
                    "@id": "/people/PieterC",
                    "fName": "Pieter",
                    "lName": "Colpaert",
                  }
                ]
              }
            </code></pre>
            <p>Dataset entities are members of the collection</p>
            <aside class="notes">   
              <ul>
                <li>First, we create a collection object</li>
                <li>entrypoint to the fragmentations of the dataset collection</li>
                <li>dataset entities are defined as members of this collection</li>
              </ul>
            </aside>
          </section>
          <section data-auto-animate>
            <pre data-id="code-animation"><codentrypoint to the fragmentations of the dataset collectione data-trim data-noescape data-line-numbers="2">
              {
                "@context":"https://w3id.org/tree#",
                "@id":"#Dataset",
                "@type":"Collection",
                ...
                "member":[...]
              }
              </code></pre>
              <p>We need to define the relations between our fragments</p>
              <aside class="notes">   
                <ul>
                  <li>There is no support yet for describing tree structures in RDF</li>
                  <li>For this we created tree ontology, describing relations between nodes of a tree structure</li>
                </ul>
              </aside>
          </section>
          <section data-auto-animate>
            <pre data-id="code-animation"><code data-trim data-noescape data-line-numbers="5-7">
              {
                "@context":"https://w3id.org/tree#",
                "@id":"#Dataset",
                "@type":"Collection",
                "view":{
                  "@id":"/fragments/root",
                },
                "member":[...]
              }
              </code></pre>
              <p>We discover the root through the view property</p>
              <aside class="notes">   
                <ul>
                  <li>From the indexing stucture, every node is used to create a fragment of the dataset.</li>
                  <li>The root nodes of the structure are then stored as views on this dataset object</li>
                </ul>
              </aside>
          </section>
          <section data-auto-animate>
            <pre data-id="code-animation"><code data-trim data-noescape data-line-numbers="3-7">
              {
                "@context":"https://w3id.org/tree#",
                "@id":"/fragments/root",
                "dct:isPartOf": {
                  "@id": "/collection"
                  "member": [...]
                },
                "relation":[
                  ...
                ]
              }
              </code></pre>
              <p>Dataset entities are members of the collection</p>
              <aside class="notes">   
                <ul>
                  <li>In these fragments, the node is then described as being part of the collection, containing the members stored in this fragment</li>
                </ul>
              </aside>
          </section>       
          <section data-auto-animate>
            <pre data-id="code-animation"><code data-trim data-noescape data-line-numbers="3,5-13">
              {
                "@context":"https://w3id.org/tree#",
                "@id":"/fragments/root",
                "dct:isPartOf": { ... },
                "relation":[
                  {
                    "@type":"GreaterThanRelation",
                    "path":"foaf:name",
                    "value":"Alice",
                    "node":"/fragments/gtAlice",
                  },
                  ...
                ]
              }
              </code></pre>
              <p style="font-size: smaller;">This relation leads to a fragment containing entities of the dataset with a <em>foaf:name</em> property greater than <em>Alice</em></p>
              <aside class="notes">   
                <ul>
                  <li>Relations to the child nodes of the structure in their containing fragments of the dataset are described by relations</li>
                  <li>This relation points to a node fragment that contains entities of the dataset that have a value for their foaf:name property that is greater than Alice</li>
                </ul>
              </aside>
          </section>             
          <aside class="notes">      
            <ul>
              <li>Finally we need a client that can traverse these generated fragmentations of a dataset</li>
            </ul>   
          </aside>
        </section>

        <section>
          <h3>What do we need</h3>
          <section>
            <ul style="width: 70vw">
              <li>a dataset index</li>
              <li>a self-describing fragmentation</li>
              <li style="color: red">a generic client</li>
            </ul>
          </section>
        </section>

        <section>
          <h3>A generic client</h3>
          <p>Query on <em>firstName</em> property for prefix <em>Carol</em></p>
          <section data-auto-animate>
            
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                </ol>
              </div>
              <div class="column">
                <div class="row center">
                  <div class="clientBlock" data-id="collectionBlock">
                    /collection
                    <pre><code data-trim data-noescape data-line-numbers>
                        {
                          "@id": "/collection"
                          "view": [
                            "/fname/root",
                            "/lname/root"
                          ]
                        }
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                </ol>
              </div>
              <div class="column">
                <div class="row center">
                  <div class="clientBlock" data-id="collectionBlock">
                    /collection
                    <pre><code data-trim data-noescape data-line-numbers="4-5">
                        {
                          "@id": "/collection"
                          "view": [
                            "/fname/root",
                            "/lname/root"
                          ]
                        }
                    </code></pre>
                  </div>
                </div>
                <div class="row">
                  <div class="column" data-id="fnameroot">
                    <div class="clientBlock">
                      /fName/root
                    </div>
                  </div>
                  <div class="column" data-id="lnameroot">
                    <div class="clientBlock">
                      /lName/root
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                  <li>Add root nodes to queue</li>
                </ol>
              </div>
              <div class="column">
                <div class="row">
                  <div class="clientBlock">
                    <div class="row" data-id="queue">
                      queue
                    </div>
                    <div class="row">
                      <div class="column" data-id="fnameroot">
                        <div class="clientBlock">
                          /fName/root
                        </div>
                      </div>
                      <div class="column" data-id="lnameroot">
                        <div class="clientBlock">
                          /lName/root
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                  <li>Add root nodes to queue</li>
                  <li>
                    Repeat
                    <ol>
                      <li>fetch node from queue</li>
                    </ol>
                  </li>
                </ol>
              </div>
              <div class="column">
                <div class="row">
                  <div class="clientBlock">
                    <div class="row" data-id="queue">
                      queue
                    </div>
                    <div class="row">
                      <div class="column" data-id="lnameroot">
                        <div class="clientBlock">
                          /lName/root
                        </div>
                      </div>
                      <div class="column">
                        <div class="clientBlock" style="border: none;">
                          <!-- placeholder -->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="row" data-id="fnameroot">
                  <div class="clientBlock">
                    /fName/root
                  </div>
                </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                  <li>Add root nodes to queue</li>
                  <li>
                    Repeat
                    <ol>
                      <li>fetch node from queue</li>
                      <li>yield matching members</li>
                    </ol>
                  </li>
                </ol>
              </div>
              <div class="column">
                <div class="row">
                  <div class="clientBlock">
                    <div class="row" data-id="queue">
                      queue
                    </div>
                    <div class="row">
                      <div class="column" data-id="lnameroot">
                        <div class="clientBlock">
                          /lName/root
                        </div>
                      </div>
                      <div class="column">
                        <div class="clientBlock" style="border: none;">
                          <!-- placeholder -->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="row" data-id="fnameroot">
                  <div class="clientBlock">
                    /fName/root
                    <pre><code data-trim data-noescape data-line-numbers="4-7" style="font-size: small; line-height:1.3em;">	
                      {
                        "@context":"https://w3id.org/tree#",
                        "@id":"/fname/root",
                        "dct:isPartOf": {
                          "@id": "/collection"
                          "member": []
                        }
                        ...
                      }
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                  <li>Add root nodes to queue</li>
                  <li>
                    Repeat
                    <ol>
                      <li>fetch node from queue</li>
                      <li>yield matching members</li>
                      <li>try to prune relations</li>
                    </ol>
                  </li>
                </ol>
                <ol>
                  <p style="font-size: smaller;">Does the relation path match the queried <em>firstName</em> property?</p>
                  <p style="font-size: smaller;">Is <em>Carol</em> greater than <em>Alice</em>?</p>
                </ol>
              </div>
              <div class="column">
                <div class="row">
                  <div class="clientBlock">
                    <div class="row" data-id="queue">
                      queue
                    </div>
                    <div class="row">
                      <div class="column" data-id="lnameroot">
                        <div class="clientBlock">
                          /lName/root
                        </div>
                      </div>
                      <div class="column">
                        <div class="clientBlock" style="border: none;">
                          <!-- placeholder -->
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="row" data-id="fnameroot">
                  <div class="clientBlock">
                    /fName/root
                    <pre><code data-trim data-noescape data-line-numbers="5-13" style="font-size: small; line-height:1.3em;">	
                      {
                        "@context":"https://w3id.org/tree#",
                        "@id":"/fname/root",
                        "dct:isPartOf": ...
                        "relation":[
                          {
                            "@type":"GreaterThanRelation",
                            "path":"foaf:name",
                            "value":"Alice",
                            "node":"/fname/gtAlice",
                          },
                          ...
                        ]
                      }
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
            <aside class="notes">         
              <ul>
                <li>in case of non matching properties we cannot decide usefulness</li>
              </ul>
            </aside>
          </section>
          <section data-auto-animate>
            <div class="row clientAlgContent">
              <div class="column">
                <ol>
                  <li>Discover fragmentations</li>
                  <li>Add root nodes to queue</li>
                  <li>
                    Repeat
                    <ol>
                      <li>fetch node from queue</li>
                      <li>yield matching members</li>
                      <li>try to prune relations</li>
                      <li>add relations to queue</li>
                    </ol>
                  </li>
                </ol>
              </div>
              <div class="column">
                <div class="row">
                  <div class="clientBlock">
                    <div class="row" data-id="queue">
                      queue
                    </div>
                    <div class="row">
                      <div class="column" data-id="lnameroot">
                        <div class="clientBlock">
                          /lName/root
                        </div>
                      </div>
                      <div class="column">
                        <div class="clientBlock" style="border-width: 1px;">
                          <b>/fname/gtAlice</b>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="row" data-id="fnameroot">
                  <div class="clientBlock">
                    /fName/root
                    <pre><code data-trim data-noescape data-line-numbers="10" style="font-size: small; line-height:1.3em;">	
                      {
                        "@context":"https://w3id.org/tree#",
                        "@id":"/fname/root",
                        "dct:isPartOf": ...
                        "relation":[
                          {
                            "@type":"GreaterThanRelation",
                            "path":"foaf:name",
                            "value":"Alice",
                            "node":"/fname/gtAlice",
                          },
                          ...
                        ]
                      }
                    </code></pre>
                  </div>
                </div>
              </div>
            </div>
          </section>
        </section>

        <section>
          <h3>Evaluation</h3>
          <section>
            <table>
              <thead>
                <tr>
                  <th>Dataset</th>
                  <th>Transport stops</th>
                  <th>OSMNames</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>entities</td>
                  <td>73k</td>
                  <td>3.87m</td>
                </tr>
                <tr>
                  <td>triples</td>
                  <td>438k</td>
                  <td>125m</td>
                </tr>
                <tr>
                  <td>query log</td>
                  <td>✔</td>
                  <td>✘</td>
                </tr>
              </tbody>
            </table>
          </section>
          <aside class="notes">         
          </aside>
        </section>

        <section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S</div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S → St</div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S → St → Stre</div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S → St → Stre → Street</div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S → St → Stre → Street → Streetname </div>
              </div>
            </div>
          </section>
          <section data-auto-animate>
            <p>Prefix queries are often processed in series</p>
            <div class="row">
              <div class="column" style="border: 1px solid black; margin:15%; text-align: left;">
                <div data-id='animated' style="margin-left: 1em;">S → St → Stre → Street → Streetname </div>
              </div>
            </div>
            <p style="font-size: smaller;">We evaluate on series of prefix autocompletion queries</p>
          </section>
        </section>

        <section>
          <p>server cache hit rate for transport stops queries</p>
          <img style="height: 40vh;" src="dist/assets/servercachehitratio.svg" alt="image">
          <p style="font-size: 0.54em;">At a 10% cache size, the baseline query server stagnates at around 20%, where our proposed
            approach can serve more than half the requests from the server cache after an initial warmup period.</p>
          <aside class="notes">  
            <ul>
              <li>baseline query server stagnates a lot sooner</li>
              <li>can serve over half evaluating queries over fragmentation</li>
              <li>REASONS</li>
              <li>more fragments being retrieved for a single query</li>
              <li>corrections in answers lead to reuse of previously cached data</li>
              <li>will not send more requests if string is not found after longest match</li>
              <li>Tree structure leads to sure hits for nodes close to the root</li>
            </ul>       
          </aside>
        </section>

        <section>
          <div>
            <p>percentage of useful results for transport stops queries</p>
            <img style="height: 40vh" src="dist/assets/efficiency.svg" alt="image">
            <p style="font-size: 0.5em;">
              A large percentage of query series in the log result in no matches, or start from a nearly completed word.
              These queries require a full traversal with few or no results, leading to bad efficiency.
              For other requests we see the efficiency averages around 50%.
            </p>
          </div>
          <aside class="notes">         
            <ul>
              <li>The efficiency shows a large quantity of 0% queries.</li>
              <li>This is due to targets that do not result in an answer (not in the collection).</li>
              <li>For other requests we see the efficiency averages over 50%</li>
              <li>Take into account that queries not always start at first letter</li>
            </ul>
          </aside>
        </section>

        <section>
          <div>
            <p>bandwidth usage for transport stops queries</p>
            <img style="height: 40vh" src="dist/assets/bandwidthandrequests2.svg" alt="image">
          </div>
          <p style="font-size: 0.5em;">
            A series of prefix autocompletion requests results in a maximum bandwidth of 25kB over this fragmentation.
            After an initial warmup of the client cache, less fragments need to be retrieved and the bandwidth requirement drops.
          </p>
          <aside class="notes">         
            <li>see that for evaluating a series of prefix queries, we can out at a maximum of 25 kb in rare cases for evaluating a series of prefix requests.</li>
            <li>see that after an initial client cache warmup, we can evaluate queries at a much lower cost</li>
            <li>This drop in bandwidth can likely be attributed also to caching</li>
            <li>This is confirmed by our analysis of the amount of HTTP requests necessary</li>
            <li>transport stops being a dataset that you will ofter request the same stops multiple times.</li>
          </aside>
        </section>

        <section>
          <section>
            <div>
              <p style="font-size: smaller;"># results retrieved for the first three queries in a series of requests over the smaller transport stops dataset</p>
              <img style="height: 40vh" src="dist/assets/stops_query_comparison.svg" alt="image">
            </div>
            <p style="font-size: 0.5em;">
              We see an average of 5 results that can be shown in the first 25 ms as a results of cached results from previous queries.
              On average queries over this fragmentation can return around 15 results in a 150 ms interval.
            </p>
            <aside class="notes">  
              <ul>
                <li>We see an average of 15 results in a 150ms interval</li>
                <li>first results because of caching</li>
                <li>later queries may not have the full 25 results available for the query, leading to a decrease in retrieved results</li>
              </ul>
              
            </aside>
          </section>
          <section>
            <div>
              <p style="font-size: smaller;"># results retrieved for the first three queries in a series of randomly generated requests over the larger OSMNames dataset</p>
              <img style="height: 40vh" src="dist/assets/osm_query_comparison.svg" alt="image">
            </div>
            <p style="font-size: 0.5em;">
              Randomized queries over a large dataset (3.87m entities) leads to a slower initial retrieval of results.
              Subsequent queries can use cached fragments to provide around 15 results in the 150 ms interval.
            </p>
            <aside class="notes">   
              <ul>
                <li>randomized queries do not start from the first letter!</li>
                <li>fragments themselves larger, as entities have more triples</li>
                <li>takes longer to retrieve and process</li>
                <li>deeper tree structure</li>
              </ul> 
            </aside>
          </section>
        </section>

        <section>
          <section>
            <p style="font-size: smaller;">Query performance per fragment size over the smaller</br>transport stops dataset</p>
            <img style="height: 32vh; margin-bottom: 0em;" src="dist/assets/stopsfragmentsize.svg" alt="image">
            <img style="margin-top: 0em;" src="dist/assets/legend_background.png"image">
            <p style="font-size: 0.45em;">
              Queries evaluated over the transport stops dataset (73k entities) can take advantage of larger fragment sizes because of the lower depth of the fragmentation structure.
              Larger fragments provide more results in a single HTTP request.
            </p>
            <aside class="notes">     
              <li>Previous results made use of a fragment size of 25.</li>    
              <li>25 entities, 25 children.</li>    
              <li>we came to this conclusion after testing different fragment sizes</li>    
              <li>for smaller datasets, we saw that larger fragment sizes were possible</li>    
            </aside>
          </section>
          <section>
            <p style="font-size: smaller;">Query performance per fragment size over the larger</br>OSMNames dataset</p>
            <img style="height: 32vh; margin-bottom: 0em;" src="dist/assets/osmNamesfragmentsize.svg" alt="image">
            <img style="margin-top: 0em;" src="dist/assets/legend_background.png"image">
            <p style="font-size: 0.45em;">
              Queries evaluated over the OSMNames dataset (3.8m entities) struggle with larger fragment sizes as initial traversal becomes more expensive.
              Smaller fragment sizes enable a faster descent in the fragmentation structure.     
            </p>
            <aside class="notes">  
              <li>but for larger dataset, the startup period to find the position in the tree to start retrieving results for the query </li>    
              <li>caused by deeper tree structure</li>    
              <li>larger fragment sizes with more data properties per entity</li>  
              <li>smaller fragments enable faster descent</li>   
              <li>as seen we do not have a one size fits all solution yet</li>   
            </aside>
          </section>
        </section>

        <section>
          <p>Querying a fragmented dataset of the address registry in Flanders</p>
          <img style="height: 50vh" src="dist/assets/autocompletionCRAB.gif" alt="image">
        </section>
        
        <section>
          <h3>Did we succeed?</h3>
          <section data-auto-animate>
            <p>
              We provide a file-based approach to fragment a dataset and publish the fragments over the Web from static solutions such as github pages, 
              that enables clients to evaluate prefix queries over the dataset with an acceptable user performance,
              while giving full client control of the query evaluation process.
            </p>
          </section>
          <section data-auto-animate>
            <p>
              We provide a <b style="color:red">file-based approach</b> to fragment a dataset and publish the fragments over the Web from static solutions such as github pages, 
              that enables clients to <b style="color:red">evaluate prefix queries</b> over the dataset with an <b style="color:red">acceptable user performance</b>,
              while giving full <b style="color:red">client control of the query evaluation process</b>.
            </p>
          </section>
        </section>

        <section>
          <h3>Where do we go from here</h3>
          <section data-auto-animate>
            <ul>
              <li>Expand to other search spaces such as geographical tiling</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul>
              <li>Expand to other search spaces such as geographical tiling</li>
              <li>Explore additional functionality such as fuzzy matching</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul>
              <li>Expand to other search spaces such as geographical tiling</li>
              <li>Explore additional functionality such as fuzzy matching</li>
              <li>The publishing of live data is discussed by my colleague at ICWE2021 in the talk <b><a href="https://docs.google.com/presentation/d/1uYzqhCV8M8XlgSZsw4GmNHPRPr-SEgWfa-xPJcZAV_Q/edit">Publishing base registries as Linked Data Event Streams</a></b></li>
            </ul>
          </section>
          <aside class="notes">         
          </aside>
        </section>

        <section>
          <h3>Try it yourself</h3> 
          <p>Query 4 datasets simultaneously!</p>         
          <section style="height: 50vh;">
            <iframe style="width: 100%; height: 100%;" src="https://treecg.github.io/treemunica_typeahead_demo/" title="A practical demonstration"></iframe>
          </section>
        </section>
        
        <section>
          <h4>If you want to applications to use your data,</br>make it attractive to reuse!</h4>
          <p>For more information and further developments,</br> come find us at</p>
          <a href="https://tree.linkeddatafragments.org/">https://tree.linkeddatafragments.org/</a>
          <p>or send me an email at</p>
          <p><b>Ruben.Dedecker@UGent.be</b></p>
        </section>


      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        autoAnimateEasing: 'ease-out',
        autoAnimateDuration: 0.6,
        autoAnimateUnmatched: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
    </script>
  </body>
</html>
